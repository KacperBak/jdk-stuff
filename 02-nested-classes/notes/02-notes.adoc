= 02 Nested classes
Kacper Bak <http://kacperbak.de>

:homepage: http://kacperbak.de
:imagesdir: ./images
:docinfo1: docinfo-footer.html

Java allows you to define a class within another class.
....
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}
....
There a two types of member classes `inner classes` and `static nested classes`
....
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
....

* A nested class is a member of its enclosing class.
* A member class can be declared private, public, protected, or package private.

WARNING: If a member class is declared **public** or **protected**, the class is being exported as an API. Any change from `inner` to `static nested` class would break binary compatibility!

There are `local classes`
....
public class OuterClass {

    ...

    public boolean block(String parameter){

        ...

        class LocalClass{

        }

        ...
    }

    ...
}
....

* Local classes are always defined inside a block.
* Local classes can access the members of its **enclosing class**.
* Local classes are non-static because they have access to instance members of the enclosing block.

There are `anonymous classes`
....
public class OuterClass {

    interface NewType{
        public void foo();
    }

    public boolean block(String parameter){

        ...

        NewType object = new NewType(){

            @Override
            public void foo(){
                ...
            }
        }
        ...
    }

    ...
}
....

* Anonymous classes are like local classes except that they do not have a name.
* Anonymous classes are expressions defined in another expression.
* Anonymous classes make your code more concise.


== Inner class

* An inner class has access to other members of the enclosing class, even **private** members.
* An inner class cannot define any static members itself, except **constants**.
* An inner class is **associated with/tied to** an instance of its enclosing class, e.g. `InnerClass` can exist only within an instance of `OuterClass`.
* This association or superfluous reference costs extra space and time, because both objects are not eligible for garbage collection.
* Use this class **ONLY** if you have to access nonstatic members of the enclosing class!

.Create an instance of an inner class
....
//First OuterClass has to be created!
OuterClass outerObject = new OuterClass();

//Then InnerClass can be created.
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
....

== Static nested class
* A **static** nested class cannot refer directly to **instance** variables or methods defined in its enclosing class.
* A **static** nested class can only access **static** members of it's enclosing class.
* A **static** nested class can be instantiated!

.Create an instance of a static nested class
....
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
....

== Local classes
* Local classes are defined in a **block** `{...}` like a method body or an `if` clause and so on.
....
public class OuterClass {

    private String regularExpression = "[^0-9]";

    public boolean validatePhoneNumber(String phoneNumber){

        int numberLength = 10;

        class PhoneNumber{

            ...

            /**
             * Access member of enclosing class - regularExpression
             */
            private String filterNumberForDigits(String rawNumber){
                return rawNumber.replaceAll( regularExpression , "");
            }

            /**
             * Access variable of enclosing block - numberLength - has been captured!
             */
            private String validateNumberForLength(String filteredNumber){
                //numberLength = 7;
                return ( filteredNumber.length() ==  numberLength) ? filteredNumber : null;
            }
        }

        ...

    }
}

....
* Local classes can access the members (e.g. _regularExpression_ ) of its **enclosing class**.

=== Captured variable
* Local classes can access the local **variables** (e.g. _numberLength_ ) or **parameters** of its **enclosing block**. - This is called **capturing**.
* Below Java 8 local classes could only access local variables that are declared **final**.
* In Java 8 local classes can access local variables that are declared **final** or are **effectively final**.
* A variable or parameter whose value is **never changed** after it is initialized is **effectively final**.
* In case that a captured variable is trying to be **assigned** (e.g. _numberLength = 7;_) the following error occurs: _local variables referenced from an inner class must be final or effectively final_.

=== Static declarations in local classes
* Local classes are in that case similar to inner classes!
* Local classes are non-static because they have access to instance members of the enclosing block.
* An constant like `private static final int CONST = 1000` can be declared, most other static declarations not.
* E.g. An `interface` is inherently static and **can't** be declared inside a block.
....
public void greetInEnglish() {
    interface HelloThere {
       public void greet();
    }
    class EnglishHelloThere implements HelloThere {
        public void greet() {
            System.out.println("Hello " + name);
        }
    }
    HelloThere myGreeting = new EnglishHelloThere();
    myGreeting.greet();
}
....

== Anonymous class
* Anonymous classes enable you to declare and instantiate a class at the same time.

....
public class OuterClass {

    private String regularExpression = "[^0-9]";

    interface PhoneNumber{
        public String getFormattedPhoneNumber(String rawNumber);
    }

    public boolean validatePhoneNumber(String phoneNumber){

        /**
         * Create instance with 'new' is like a constructor invocation.
         */
        PhoneNumber processedNumber = new PhoneNumber(){


            @Override
            public String getFormattedPhoneNumber(String rawNumber) {
                return formatNumber(rawNumber);
            }

            ...

            /**
             * Access member of enclosing class - regularExpression
             */
            private String filterNumberForDigits(String rawNumber){
                return rawNumber.replaceAll( regularExpression , "");
            }

            ...
        };

        ...
    }
}

....
* The syntax of an anonymous class expression is like the invocation of a constructor inside a block of code. A new Instance is being created.
* Like local classes, anonymous classes can access the **members** of its **enclosing class**.
* Like local classes, anonymous classes can access the local **variables** or **parameters** of its **enclosing block**. - This is called **capturing**.
* Similar to local classes those **variables** or **parameters** has to be **final** or **effectively final**.
* Anonymous classes also have the same **static** restrictions as local classes with respect to their members.
* Like nested classes, **shadowing** is possible in case of declarations of same **type** with **same name** in inner and outer class.

== When to use what?
=== Nested classes
* If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together.
* To increases encapsulation: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private.
By hiding class B within class A, A's members can be declared private and B can access them. In addition, B itself should be hidden from the outside world, with a `private` constructor.

NOTE: A nested class should **ONLY** serve its enclosing class! If a nested class would be useful in some other context, then it should be a **top-level** class!

=== Inner class
* If you declare a nested class that **does** require access to an enclosing instance, declare an inner class.

=== Static nested class
* If you declare a nested class that **does not** require access to an enclosing instance, always put the `static` modifier in its declaration.

=== Local class
* Check Oracle and Effective Java for proper usage. ...

=== Anonymous class
* Anonymous classes are eligible if only one instance is needed.
* Anonymous classes are ideal for implementing an interface that contains **two** or **more** methods.

== Shadowing
* If a declaration of a type of the inner scope has the same name as another declaration in the outer scope, then the declaration shadows the declaration of the outer scope.
* You cannot refer to a shadowed declaration by its name alone.

NOTE: Inner scope shadows outer scope

....
public class ShadowTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {

            //x = 23
            System.out.println("x = " + x);

            //this.x = 1
            System.out.println("this.x = " + this.x);

            //ShadowTest.this.x = 0
            System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);
        }
    }

    public static void main(String... args) {
        ShadowTest st = new ShadowTest();
        ShadowTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}
....

== Serialization
* Serialization of inner classes, including local and anonymous classes, is strongly discouraged.
* Possible compatibility issues can  occur if you serialize an inner class and then deserialize it with a different JRE implementation.


== Sources
* http://docs.oracle.com/javase/tutorial/java/javaOO/nested.html[The Java™ Tutorials - Nested classes]
* http://docs.oracle.com/javase/tutorial/java/javaOO/innerclasses.html[The Java™ Tutorials - Inner Class Example]
* http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html[The Java™ Tutorials - Local Classes]
* http://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html[The Java™ Tutorials - Anonymous Classes]
* http://www.amazon.de/Effective-Java-Programming-Language-Guide/dp/0321356683/ref=sr_1_1?ie=UTF8&qid=1420652823&sr=8-1&keywords=Effective+Java[Effective Java by Joshua Bloch - Item 22: Favor static member classes over nonstatic]

